<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="/style.css">
    <link rel="icon" href="/icons/foop.png">

    <title>FootyLive</title>
</head>

<body>
    <h1 id="loadingHeader"></h1>
    <button id="darkModeToggle"><i class="fa-solid fa-star-half-stroke"></i></button>
    <div class="scoreboard">
        <div class="team homeTeamContainer">
            <img id="homeTeamIcon" src="" alt="Home Team Logo">
            <div class="teamInfo">
                <h2 id="homeTeamScore"></h2>
                <p id="homeTeamSecondaryScore"></p>
            </div>
        </div>
        <div class="gameInfo">
            <h2 id="currentPeriod"></h2>
            <p id="margin"></p>
            <p id="gamePercentage"></p>
        </div>
        <div class="team awayTeamContainer">
            <div class="teamInfo">

                <h2 id="awayTeamScore"></h2>
                <p id=awayTeamSecondaryScore></p>
            </div>
            <img id="awayTeamIcon" src="" alt="Away Team Logo">
        </div>
    </div>


    <div class="container">

        <div class="table-container">
            <div class="teamAndTime">
                <h3 id="homeTeam"></h3>
            </div>
            <table id="team0">
                <tr>
                    <th><i class="fa-solid fa-circle tableFocus"></i></th>
                    <th></th>
                    <th class="playerNameHeader">Name</th>
                    <th class="hide-on-mobile">G.B</th>
                    <th class="">K</th>
                    <th class="">H</th>
                    <th class="">M</th>
                    <th class="">T</th>
                    <th>TOG</th>
                    <th>AVG</th>
                    <th>BE</th>
                    <th>AF</th>
                    <!-- <th>SC</th> -->
                </tr>
                <!-- Player data for Team 0 will be inserted here -->
            </table>
        </div>
        <div class="table-container">
            <div class="teamAndTime">
                <h3 id="awayTeam"></h3>
            </div>
            <table id="team1">
                <tr>
                    <th><i class="fa-solid fa-circle tableFocus"></i></th>
                    <th></th>
                    <th class="playerNameHeader">Name</th>
                    <th class="hide-on-mobile">G.B</th>
                    <th class="">K</th>
                    <th class="">H</th>
                    <th class="">M</th>
                    <th class="">T</th>
                    <th>TOG</th>
                    <th>AVG</th>
                    <th>BE</th>
                    <th>AF</th>
                    <!-- <th>SC</th> -->
                </tr>
                <!-- Player data for Team 1 will be inserted here -->
            </table>
        </div>
    </div>

    <div id="tooltip">
        <div class="triangle"></div>
        <i class="fa-solid fa-xmark" id="close-btn" onclick="closeTooltip()"></i>
        <img src="" alt="">
        <ul>
            <li>
                <div class="circle" id="orange"></div>
            </li>
            <li>
                <div class="circle" id="blue"></div>
            </li>
            <li>
                <div class="circle" id="purple"></div>
            </li>
            <li>
                <div class="circle" id="default"></div>
            </li>
        </ul>
        <ul>
            <!-- <li><i class="customIcon" id="injuredOut" style="content: url('/icons/redcross.png')"></i></li> -->
            <li><i class="customIcon" id="fire" style="content: url('/icons/fire.png')"></i></li>
            <li><i class="customIcon" id="ice" style="content: url('/icons/ice.png')"></i></li>
            <li><i class="customIcon" id="subbedOut" style="content: url('/icons/redvest.png')"></i></li>
            <li><i class="customIcon" id="tagged" style="content: url('/icons/padlock.png')"></i></li>
            <li><i class="customIcon" id="tagger" style="content: url('/icons/tag.png')"></i></li>
        </ul>
        <button id="timelineBtn">View Timeline</button>
    </div>

    <div id="timelineHolder">
        <span id="timelineInfo">
            <img id="timelineImage" style="width: 150px" src="" alt="Player image">
            <div id="timelineText">
                <p id="timelinePlayerName">Name</p>
                <p id="playerPrice">Price</p>
                <p id="playerPosition">Position</p>
                <p id="playerBreakeven">BE</p>
            </div>
        </span>
        <div>
            <table id="timelineTable">
                <tr>
                    <th></th>
                    <th id="Q1Header">Q1</th>
                    <th id="Q2Header">Q2</th>
                    <th id="Q3Header">Q3</th>
                    <th id="Q4Header">Q4</th>
                </tr>
                <tr>
                    <td><i id="hideTimeline" class="fa-solid fa-eye"></i></td>
                    <td id="Q1"></td>
                    <td id="Q2"></td>
                    <td id="Q3"></td>
                    <td id="Q4"></td>
                </tr>

            </table>
        </div>
    </div>


    <div class="message-container">
        <div class="chatbutton-container">
            <button id="FootyLiveChat">FootyLive</button>
            <button id="DTLiveChat">DTLive</button>
        </div>
        <div id="chatFeed"></div>
        <span class="chat-span">
            <div class="input-container">
                <input id="messageInput" type="text" placeholder="Send message">
                <button id="messageButton" onclick="sendMessage()"><i class="fa-regular fa-comment"></i></button>
            </div>
            <div class="input-container">
                <input id="usernameInput" type="text" placeholder="Change username">
                <button id="usernameButton"><i class="fa-solid fa-pencil"></i></button>
            </div>
        </span>
    </div>
    <div id="backButton"><a href="/fixture"><i class="fa-solid fa-arrow-left-long"></i></a></div>

    <script>
        // FOR PRODUCTION
        const socket = new WebSocket('wss://footylive.onrender.com:8080');
        // const socket = new WebSocket('ws://localhost:8080');
        
        
        var allowColourChange = true;

        let tableFocusBtns = document.getElementsByClassName('tableFocus')

        for (let i = 0; i < tableFocusBtns.length; i++) {
            let homeTeam = document.getElementById("homeTeam");
            let awayTeam = document.getElementById("awayTeam");

            tableFocusBtns[i].addEventListener('click', function () {
                let team = i > 0 ? awayTeam : homeTeam;
                team.scrollIntoView({ behavior: 'smooth' });
            });
        }

        document.addEventListener('DOMContentLoaded', (event) => {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
        });
        // Variable to prevent colour changes when there is a stat update


        // Store the colours of each row
        const rowColours = {};

        // store the icons selected on each row
        const rowIcons = {};

        // Store the previous data of each player
        const previousDataTeam0 = {};
        const previousDataTeam1 = {};

        // Store team names and scores
        const homeTeam = document.getElementById('homeTeam');
        const awayTeam = document.getElementById('awayTeam');
        const homeTeamScore = document.getElementById('homeTeamScore');
        const homeTeamSecondaryScore = document.getElementById('homeTeamSecondaryScore');
        const awayTeamSecondaryScore = document.getElementById('awayTeamSecondaryScore');
        const awayTeamScore = document.getElementById('awayTeamScore');
        const homeTeamIcon = document.getElementById('homeTeamIcon');
        const awayTeamIcon = document.getElementById('awayTeamIcon');
        let currentTime = 0;

        // Define global variables to store player data for each team
        window.playerData = { team0: [], team1: [] };
        let injuryList = [];
        // Function to format player data into table rows and order by fantasy
        function formatPlayerData(team, previousData) {
            const tableContainer = document.querySelector('.container');
            tableContainer.style.visibility = 'visible';
            const loadingHeader = document.getElementById('loadingHeader');
            loadingHeader.style.display = 'none';

            const tableId = `team${team}`;
            const table = document.getElementById(tableId);
            const tbody = table.querySelector('tbody');
            const teamData = window.playerData[`team${team}`];

            if (teamData && teamData.length > 0) {
                while (tbody.children.length > 1) {
                    tbody.removeChild(tbody.children[1]);
                }
            }


            if (teamData && Array.isArray(teamData)) {
                //closeTooltip();


                // Get the first player of each team
                const firstPlayerTeam0 = teamData.find(player => player.team === 0);
                const firstPlayerTeam1 = teamData.find(player => player.team === 1);

                // Set team name and scores for home team
                if (firstPlayerTeam0) {
                    homeTeam.textContent = `${firstPlayerTeam0.teamName}`;
                    homeTeamScore.textContent = `${firstPlayerTeam0.teamScoreTotal}`;
                    homeTeamSecondaryScore.textContent = `${firstPlayerTeam0.teamScore}`;
                    // console.log(firstPlayerTeam0)
                    homeTeamIcon.src = `/svg/${firstPlayerTeam0.teamName.replace(/\s/g, '')}.svg`;

                    currentTime = `${firstPlayerTeam0.time}`;
                }

                // Set team name and scores for away team
                if (firstPlayerTeam1) {
                    awayTeam.textContent = `${firstPlayerTeam1.teamName}`;
                    awayTeamScore.textContent = `${firstPlayerTeam1.teamScoreTotal}`;
                    awayTeamSecondaryScore.textContent = `${firstPlayerTeam1.teamScore} `;

                    awayTeamIcon.src = `/svg/${firstPlayerTeam1.teamName.replace(/\s/g, '')}.svg`;
                }

                calculateGamePercentage(currentTime);

                // Sort the players by their fantasy score
                const sortedPlayers = teamData.sort((a, b) => b.fantasy - a.fantasy);

                sortedPlayers.forEach(player => {
                    if (player.team === team) {
                        const row = document.createElement('tr');
                        const playerId = `${player.name}-${player.number}`;
                        const previousColour = rowColours[playerId];

                        const timeArray = player.time.split(' ');
                        const quarterFull = timeArray[1];

                        const differences = calculateDifferences(player, previousData[playerId]);
                        const cells = [
                            `<td id="iconHolder"></td>`,
                            `<td>${player.number}</td>`,
                            `<td class="playerName">${player.name}</td>`,
                            `<td class="hide-on-mobile">${parseInt(player.goals)}.${parseInt(player.behinds)}${renderSuperscript(differences.goals, quarterFull)}${renderSuperscript(differences.behinds, quarterFull, "behinds")}</td>`,
                            `<td class="">${parseInt(player.kicks)}${renderSuperscript(differences.kicks, quarterFull)}</td>`,
                            `<td class="">${parseInt(player.handballs)}${renderSuperscript(differences.handballs, quarterFull)}</td>`,
                            `<td class="">${parseInt(player.marks)}${renderSuperscript(differences.marks, quarterFull)}</td>`,
                            `<td class="">${parseInt(player.tackles)}${renderSuperscript(differences.tackles, quarterFull)}</td>`,
                            `<td>${parseInt(player.tog)}%</td>`,
                            `<td>${parseInt(player.fantasyAvg)}</td>`,
                            `<td class="breakeven">${parseInt(player.breakeven)}</td>`,
                            `<td>${parseInt(player.fantasy)}${renderSuperscript(differences.fantasy, quarterFull)}</td>`,
                            //`<td>${parseInt(player.supercoach)}${renderSuperscript(differences.supercoach, quarterFull)}</td>`,
                        ];


                        row.innerHTML = cells.join('');
                        tbody.appendChild(row);
                        row.id = playerId;

                        let breakeven = row.querySelector('.breakeven');
                        if (parseInt(player.fantasy) >= parseInt(player.breakeven)) {
                            breakeven.style.color = '#3f941e';
                        } else {
                            breakeven.style.color = '#b13b3b';
                        }

                        // const previousIcon = rowIcons[playerId];
                        // if (previousIcon) {
                        //     addIcon(row, previousIcon);
                        // }

                        if (player.sub == 1) {
                            addIcon(row, '<i class="customIcon" id="subsitute" style="content: url(\'/icons/greenvest.png\')"></i>');
                        }

                        if (player.benched == 1) {
                            // Add a p element to the .playerName element containing the word "BEN"

                            const playerName = row.querySelector('.playerName');
                            playerName.style.opacity = "20%";
                            // const benched = document.createElement('span');
                            // benched.textContent = "BEN";
                            // benched.classList.add('benched');
                            // playerName.appendChild(benched);
                        }

                        // Get the icon currently on the player

                        let injuredIcon = rowIcons[playerId] === '<i class="customIcon" id="injuredOut" style="content: url(\'/icons/redcross.png\')"></i>';
                        if (player.injured == 1 || injuredIcon) {
                            if (!injuryList.includes(playerId)) {
                                injuryList.push(playerId);
                            };
                            if (player.benched != 1 && injuryList.includes(playerId)) {
                                addIcon(row, '<i class="customIcon" id="injuredPlaying" style="content: url(\'/icons/bandaid.png\')"></i>');
                            }

                            fetch('/get-all-icons')
                                .then(response => {
                                    if (!response.ok) {
                                        throw new Error('Failed to fetch icons');
                                    }
                                    return response.json();
                                })
                                .then(iconsData => {
                                    // Update the table with fetched icons
                                    // If playerId in iconsData and the player has redvest icon, don't add redcross
                                    if (iconsData && iconsData[playerId] !== "<i class=\"customIcon\" id=\"subbedOut\" style=\"content: url('/icons/redvest.png')\"></i>") {
                                        addIcon(row, '<i class="customIcon" id="injuredOut" style="content: url(\'/icons/redcross.png\')"></i>');
                                    }
                                });
                        }
                        // console.log("Injury List: " + injuryList);
                        handleRowColorAndSuperscripts(row, playerId, differences);

                        //fetchScoringTimeline(playerId);

                        row.querySelector(".playerName").addEventListener('click', function (event) {
                            showTooltip(playerId, player.team, row, event.clientX, event.clientY, player);
                        });

                        if (player.team === 0) {
                            Object.assign(previousDataTeam0[playerId], player);
                        } else {
                            Object.assign(previousDataTeam1[playerId], player);
                        }


                    }
                });
                fetchAndUpdateIcons();

                if (currentTimelinePlayer) {
                    //console.log("Fetching current Player");
                    fetchScoringTimeline(currentTimelinePlayer, firstPlayerTeam0.round);
                }
            } else {
                console.error(`Player data for Team ${team} is not available or not in the expected format.`);
            }
        }

        function handleRowColorAndSuperscripts(row, playerId, differences) {
            const fantasyDifference = differences.fantasy;
            const anyStatChanged = Object.values(differences).some(diff => diff !== 0 && !isNaN(diff));
            // // if (row.style.backgroundColor == '') {
            //     handleRowColorChange(row, fantasyDifference);
            // // }
            handleRowColorChange(row, fantasyDifference);

            if (anyStatChanged) {
                row.querySelectorAll('sup').forEach(sup => {
                    sup.style.visibility = 'visible';
                });
                allowColourChange = false;
            }

            if (allowColourChange && rowColours[playerId]) {
                handleRowColor(row, rowColours[playerId]);
            }
        }

        function handleRowColorChange(row, fantasyDifference) {
            if (fantasyDifference > 0) {
                row.style.backgroundColor = 'lightgreen';
            } else if (fantasyDifference < 0) {
                row.style.backgroundColor = 'lightcoral';
            }

            const colorMap = {
                'default': '',
                'orange': 'rgb(247, 190, 129)',
                'blue': 'rgb(206, 227, 246)',
                'purple': 'rgb(227, 206, 246)'
            };

            if (fantasyDifference === 0) {
                row.style.backgroundColor = colorMap[rowColours[row.id]] || '';
                if (row.style.backgroundColor != '') {
                    row.style.color = "#2a2a2a"
                }
            }

            setTimeout(() => {
                if (['', 'lightgreen', 'lightcoral'].includes(row.style.backgroundColor)) {
                    row.style.backgroundColor = colorMap[rowColours[row.id]] || '';
                    if (row.style.backgroundColor != '') {
                        row.style.color = "#2a2a2a"
                    }
                    allowColourChange = true;
                }
            }, 5000);
        }


        function handleRowColor(row, color) {
            const colorMap = {
                'default': '',
                'orange': 'rgb(247, 190, 129)',
                'blue': 'rgb(206, 227, 246)',
                'purple': 'rgb(227, 206, 246)'
            };
            row.style.backgroundColor = colorMap[color] || '';
            if (colorMap[color]) {
                row.style.color = '#2a2a2a';
            }

            if (colorMap[color] === '') {
                localStorage.removeItem(row.id, color);
            } else {
                localStorage.setItem(row.id, color);
            }
        }


        window.onload = function () {
            // Get all the rows
            var rows = document.getElementsByTagName('tr');

            // Iterate over the rows
            for (var i = 0; i < rows.length; i++) {
                // Get the row's id
                var id = rows[i].id;

                // Check if a color is stored in local storage for this id
                var color = localStorage.getItem(id);

                // If a color is stored, apply it to the row
                if (color) {
                    rowColours[id] = color;
                    handleRowColor(rows[i], color);
                }
            }
        };



        let colourCircleClickHandlers = [];
        let iconClickHandlers = [];

        function showTooltip(playerId, team, row, x, y, player) {
            if (!allowColourChange) {
                //return;
            }
            if (!row) return; // Exit if player row element is not found
            const tooltip = document.getElementById("tooltip");
            const img = tooltip.querySelector("img");
            img.src = `/images/${playerId}.png`;
            // Show tooltip
            tooltip.style.position = "absolute";



            const playerName = document.getElementById(playerId);
            const rect = playerName.getBoundingClientRect();
            let middle = 0;

            const tooltipHeight = tooltip.offsetHeight;
            let tableHeight = row.parentElement.offsetHeight;
            let tooltipBottom = y + tooltipHeight + window.scrollY;
            const tooltipTop = y - tooltipHeight + window.scrollY;
            let yOffset = 20;
            const triangle = document.querySelector('.triangle');

            switch (team) {
                case 0:

                    middle = rect.left;
                    break;
                case 1:
                    if (window.innerWidth <= 768) {
                        middle = rect.left;
                        tooltipBottom -= 900;
                        //yOffset *= 3;
                        //tableHeight += window.innerHeight;
                    } else {

                        middle = rect.left;
                    }
                    break;
                default:
                    break;
            }

            if (tooltipBottom > tableHeight) {
                // If the tooltip would go past the bottom of the viewport, display it above the mouse position
                tooltip.style.top = `${y - tooltipHeight + window.scrollY - (yOffset)}px`;
                tooltip.classList.add('above');
                triangle.classList.add('above');
            } else {
                // Otherwise, display it below the mouse position
                tooltip.style.top = `${y + window.scrollY + yOffset}px`;
                tooltip.classList.remove('above');
                triangle.classList.remove('above');
            }

            if (window.innerWidth > 768) {
                tooltip.style.left = `${middle}px`;


            } else {
                tooltip.style.left = `${middle}px`;
            }

            tooltip.style.opacity = "100";
            tooltip.style.pointerEvents = "auto";


            var colourCircles = document.getElementsByClassName("circle");
            for (let i = 0; i < colourCircles.length; i++) {
                if (colourCircleClickHandlers[i]) {
                    colourCircles[i].removeEventListener('click', colourCircleClickHandlers[i]);
                }

                colourCircleClickHandlers[i] = function () {
                    let colour = colourCircles[i].id;
                    toggleRowColour(row, colour);
                };

                colourCircles[i].addEventListener('click', colourCircleClickHandlers[i]);
            }

            var icons = tooltip.getElementsByTagName("i");
            for (let i = 0; i < icons.length; i++) {
                if (icons[i].id != 'close-btn') {
                    if (iconClickHandlers[i]) {
                        icons[i].removeEventListener('click', iconClickHandlers[i]);
                    }

                    iconClickHandlers[i] = function () {
                        let icon = icons[i].outerHTML;
                        addIcon(row, icon);
                    };

                    icons[i].addEventListener('click', iconClickHandlers[i]);
                }
            }


            tooltip.querySelector("#timelineBtn").addEventListener('click', function handleClick(event) {
                showTimeline(playerId, player);
                closeTooltip();
                tooltip.querySelector("#timelineBtn").removeEventListener('click', handleClick);
            });

        }

        function closeTooltip() {
            const tooltip = document.getElementById("tooltip");
            tooltip.style.opacity = 0;
            tooltip.style.pointerEvents = "none";
        }

        function removeTimelineEventListener(tooltip) {
            const timelineBtn = tooltip.querySelector("#timelineBtn");
            timelineBtn.removeEventListener('click', showTimeline);
        }




        function addIcon(row, icon) {
            if (row == null) { return; }
            var playerName = row.getElementsByClassName("playerName")[0];
            if (playerName == undefined) { return; }

            var existingIcon = row.querySelector("i");
            if (existingIcon) {
                // Remove the existing icon (we only allow 1 icon at a time)
                existingIcon.remove();
            }
            var iconCol = row.querySelector("#iconHolder");
            iconCol.innerHTML = `${icon}`;
            let playerId = row.id;
            rowIcons[playerId] = icon;
            closeTooltip();

            iconCol.querySelector("i").addEventListener('click', function () {
                // Remove icon from the DOM
                this.remove();
                delete rowIcons[playerId];
                // Send request to the server to remove the icon
                fetch('/remove-icon', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        playerId: playerId,
                    }),
                })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Network response was not ok');
                        }
                        // Handle success if needed
                    })
                    .catch(error => {
                        console.error('Error removing icon:', error);
                    });

                fetchAndUpdateIcons();
            });

            fetch('/update-icon', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    playerId: playerId,
                    icon: icon,
                }),
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    // Handle success if needed
                })
                .catch(error => {
                    console.error('Error updating icon:', error);
                });
        }


        function fetchAndUpdateIcons() {
            // Fetch icons from the server
            fetch('/get-all-icons')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to fetch icons');
                    }
                    return response.json();
                })
                .then(iconsData => {
                    // Update the table with fetched icons
                    for (const playerId in iconsData) {
                        const icon = iconsData[playerId];
                        const row = document.getElementById(playerId);
                        if (row) {
                            addIcon(row, icon);
                        }
                    }
                })
                .catch(error => {
                    console.error('Error fetching icons:', error);
                });
        }




        function toggleRowColour(row, colour) {
            if (!allowColourChange || row == null) {
                return;
            }

            var playerId = row.id;

            // Apply the next color to the row
            switch (colour) {
                case 'default':
                    row.style.backgroundColor = '';
                    row.style.color = "var(--text-color)"
                    localStorage.removeItem(row.id, colour);
                    break;
                case 'orange':
                    row.style.backgroundColor = 'rgb(247, 190, 129)';
                    row.style.color = "#2a2a2a"
                    break;
                case 'blue':
                    row.style.backgroundColor = 'rgb(206, 227, 246)';
                    row.style.color = "#2a2a2a"
                    break;
                case 'purple':
                    row.style.backgroundColor = 'rgb(227, 206, 246)';
                    row.style.color = "#2a2a2a"
                default:
                    break;
            }

            if (colour != 'default') {
                rowColours[playerId] = colour;
                localStorage.setItem(row.id, colour);
            } else {
                delete rowColours[playerId];
            }
            closeTooltip();
        }

        ////////////////////////////////////
        // async function fetchGameStats(trimmedLink, playerName) {
        //     try {
        //         const response = await fetch(`/player-stats/${trimmedLink}`);
        //         if (!response.ok) {
        //             throw new Error(`HTTP error! status: ${response.status}`);
        //         }
        //         const allStats = await response.json();
        //         const playerStats = allStats.players.find(player => player.name === playerName);
        //         if (playerStats) {
        //             // console.log(playerStats);
        //             let quarterStats = playerStats[trimmedLink].q2;
        //             console.log(quarterStats)
        //             // Now you can use playerStats.goals, playerStats.behinds, etc.
        //         } else {
        //             console.log('Player not found');
        //         }
        //     } catch (error) {
        //         console.log('There was a problem fetching the game stats:', error);
        //     }
        // }

        // // Call the function with the trimmed link and player name
        // fetchGameStats('5977', 'C.Warner');


        //////////////////////////////////

        function calculateDifferences(newPlayer, oldPlayer) {
            const differences = {};

            if (oldPlayer) {
                const keys = ['goals', 'behinds', 'kicks', 'handballs', 'marks', 'tackles', 'hitouts', 'fantasy', 'freesfor', 'freesagainst'];

                keys.forEach(key => {
                    differences[key] = newPlayer[key] - oldPlayer[key];
                });
            } else {
                Object.keys(newPlayer).forEach(key => {
                    differences[key] = 0;
                });
            }

            return differences;
        }

        function fetchScoringTimeline(playerId, round) {
            fetch(`/scoringTimeline/${playerId}/${round}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Network response was not ok, status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data) {
                        formatScoringTimeline(playerId, data);
                    }
                })
                .catch(error => {
                    alert('The scoring timeline data is missing or unavailable.', error);
                });
        }

        function formatScoringTimeline(playerId, data) {
            const timelineTable = document.getElementById('timelineTable');
            if (!timelineTable) {
                console.error("Timeline table not found");
                return;
            }

            // Clear existing content
            for (let i = 1; i <= 4; i++) {
                const col = document.querySelector(`#Q${i}`);
                if (col) {
                    col.innerHTML = '';
                }
            }

            data.forEach(entry => {
                const { quarter, time, stat, difference, fantasy } = entry;
                const sign = fantasy > 0 ? '+' : '';

                if (quarter >= 1 && quarter <= 4 && entry != 'fantasy') {
                    const col = document.querySelector(`#Q${quarter}`);
                    if (col) {
                        const p = document.createElement('p');
                        p.textContent = `${time}: ${sign}${fantasy} (${difference}${stat})`;
                        if (col.firstChild) {
                            col.insertBefore(p, col.firstChild);
                        } else {
                            col.appendChild(p);
                        }
                    }
                }
            });

            for (let i = 1; i <= 4; i++) {
                const header = document.getElementById(`Q${i}Header`);
                if (header) {
                    header.innerText = `Q${i} (${calculateQuarterScore(`Q${i}`)})`;
                }
            }
        }

        let currentTimelinePlayer;
        function showTimeline(playerId, player) {
            if (currentTimelinePlayer != playerId) {
                for (let i = 1; i <= 4; i++) {
                    const col = document.querySelector(`#Q${i}`);
                    col.innerHTML = '';
                }
            }

            currentTimelinePlayer = playerId;
            const timelineHolder = document.getElementById('timelineHolder');
            timelineHolder.style.display = 'flex';
            const timelineTable = document.getElementById('timelineTable');
            timelineTable.style.display = 'table';
            timelineHolder.querySelector('img').src = `/images/${playerId}.png`;
            timelineHolder.querySelector('#timelinePlayerName').textContent = `${playerId.replace(/-/g, ' ')}`;
            timelineHolder.querySelector("#hideTimeline").addEventListener('click', handleHideTimelineClick);
            timelineHolder.scrollIntoView({ behavior: 'smooth' });

            if (player.position.includes("FOR")) {
                player.position = player.position.replace("FOR", "FWD");
            }
            const timelinePrice = timelineHolder.querySelector('#playerPrice');
            timelinePrice.innerText = player.price;
            const timelinePosition = timelineHolder.querySelector('#playerPosition');
            timelinePosition.innerText = player.position;
            const timelineBreakeven = timelineHolder.querySelector('#playerBreakeven');
            timelineBreakeven.innerText = "BE: " + player.breakeven;


            fetchScoringTimeline(playerId, player.round);
        }

        function handleHideTimelineClick() {
            hideTimeline(timelineHolder);
        }

        function calculateQuarterScore(quarter) {

            let scoringTimeline = document.getElementById(`${quarter}`).textContent;
            let quarterSum = 0;
            let scoringTimelineText = scoringTimeline.replace(/\s/g, '');
            let positiveScores = scoringTimelineText.split('+').map(data => data.split("(")[0]);
            let negativeScores = scoringTimelineText.split('-').map(data => data.split("(")[0]);
            positiveScores.forEach(score => {
                if (/^\d+$/.test(score)) {
                    quarterSum += parseInt(score);
                }
            });
            negativeScores.forEach(score => {
                if (/^\d+$/.test(score)) {
                    quarterSum -= parseInt(score);
                }
            });

            return quarterSum;
        }

        //formatScoringTimeline('S.Walsh-18');



        function hideTimeline(timelineTable) {
            timelineTable.style.display = 'none';
            for (let i = 1; i <= 4; i++) {
                const col = document.querySelector(`#Q${i}`);
                col.innerHTML = '';
            }
            currentTimelinePlayer = undefined;
            timelineTable.querySelector("#hideTimeline").removeEventListener('click', handleHideTimelineClick);
        }

        // Function to render superscript based on difference
        function renderSuperscript(diff, time, behinds) {
            //console.log(time);
            if (diff !== 0 && time !== 'Time') {
                var diffInt = parseInt(diff);
                const color = diffInt > 0 ? 'green' : 'red';
                const sign = diffInt > 0 ? '+' : '';
                hideSuperscript();
                if (behinds == "behinds") {
                    return `<sup style="color: ${color};">${sign}.${diffInt}</sup>`;
                }
                return `<sup style="color: ${color};">${sign}${diffInt}</sup>`;
            } else {
                return '';
            }
        }

        function hideSuperscript() {
            setTimeout(() => {
                document.querySelectorAll('sup').forEach(sup => {
                    sup.style.visibility = 'hidden';
                });
                //fetchAndFormatPlayerData();
            }, 5000);
        }


        let trimmedLink = window.location.href.split('/').pop();

        // Function to fetch player data and format it
        function fetchAndFormatPlayerData() {
            Promise.all([
                fetch(`/player-stats/${trimmedLink}`),
                //fetch(`/${trimmedLink}/player-stats/?team=1`)
            ])
                .then(responses => Promise.all(responses.map(response => response.json())))
                .then(data => {
            
                    const team0Players = data[0].players.filter(player => player.team === 0);
                    const team1Players = data[0].players.filter(player => player.team === 1);
                  
                    team0Players.forEach(player => {
                        const playerId = `${player.name}-${player.number}`;
                        if (!previousDataTeam0[playerId]) {
                            previousDataTeam0[playerId] = { ...player }; // Create a copy of the player data
                        }
                        //formatScoringTimeline(playerId);
                    });
                    team1Players.forEach(player => {
                        const playerId = `${player.name}-${player.number}`;
                        if (!previousDataTeam1[playerId]) {
                            previousDataTeam1[playerId] = { ...player }; // Create a copy of the player data
                        }
                        //formatScoringTimeline(playerId);
                    });

                    window.playerData.team0 = team0Players;
                    window.playerData.team1 = team1Players;
                    
                    formatPlayerData(0, previousDataTeam0);
                    formatPlayerData(1, previousDataTeam1);
                });
        }


        fetchAndFormatPlayerData(trimmedLink);

        // Function to fetch data every 10 seconds
        socket.onmessage = function (event) {
            if (event.data === 'playerDataChanged') {
                // console.log("UPDATING")
                fetchAndFormatPlayerData(trimmedLink);
            }
            else {
                console.log(event.data);
            }
        };

        function calculateGamePercentage(currentTime) {

            // const currentTime = document.getElementById('currentTime').textContent;

            const currentPeriod = document.getElementById('currentPeriod');
            currentPeriod.textContent = currentTime;

            let homeTeamScore = parseInt(document.getElementById('homeTeamScore').textContent);
            let awayTeamScore = parseInt(document.getElementById('awayTeamScore').textContent);
            let homeTeam = document.getElementById('homeTeam').textContent;
            let awayTeam = document.getElementById('awayTeam').textContent;
            const marginHolder = document.getElementById('margin');
            const highestScore = Math.max(homeTeamScore, awayTeamScore);
            const lowestScore = Math.min(homeTeamScore, awayTeamScore);
            const margin = highestScore - lowestScore;

            const timeArray = currentTime.split(' ');
            const quarter = timeArray[0][1];
            const quarterFull = timeArray[1];
            let minutes = 0;
            

            if (homeTeamScore == highestScore) {
                marginHolder.innerHTML = `${homeTeam} <br>by ${margin}`;
            }
            else {
                marginHolder.innerHTML = `${awayTeam} <br>by ${margin}`;
            }
            if (homeTeamScore == awayTeamScore) {
                if (quarter == 0) {
                    marginHolder.textContent = "TBD";
                } else {
                    if (quarterFull == 'Time') {
                        marginHolder.textContent = "Draw";
                    }
                    else {
                        marginHolder.textContent = "Scores level"
                    }
                }
            }

            if (quarter == '0') {
                const gamePercentage = document.getElementById('gamePercentage');
                gamePercentage.textContent = '0%';
                return;
            }
            try {
                minutes = timeArray[1].split(':')[0];
            } catch {
                minutes = 120;
            }
            
            let percentage = ((parseInt(minutes) / 120) * 100) + ((parseInt(quarter) - 1) * 25);
            //console.log(quarterFull)
            switch (quarterFull) {
                case 'Q1':
                    if (percentage >= 25) {
                        percentage = 24;
                    }
                    break;
                case 'Q2':
                    if (percentage >= 50) {
                        percentage = 49;
                    }
                    break;
                case "Q3":
                    if (percentage >= 75) {
                        percentage = 74;
                    }
                    break;
                case 'Q4':
                    if (percentage >= 100) {
                        percentage = 99;
                    }
                    break;
                case 'QTR':
                    percentage = 25;
                    break;
                case 'HALF':
                    percentage = 50;
                    break;
                case '3':
                    percentage = 75;
                    break;
                case '4':
                    percentage = 100;
                    break;
                case 'Time':
                    percentage = 100;
                    break;
                default:
                    break;
            }
            if (percentage > 100) {
                percentage = 100;
            }
            const gamePercentage = document.getElementById('gamePercentage');
            gamePercentage.textContent = Math.ceil(percentage) + '%';


            fireAndIce(percentage);
        }

        function fireAndIce(percentage) {
            const playerNames = document.getElementsByClassName("playerName");
            let averages = [];
            let fantasy = [];
            for (let i = 0; i < playerNames.length; i++) {
                const average = playerNames[i].parentElement.lastElementChild.previousElementSibling.previousElementSibling.textContent;
                averages.push(average);
                const fantasyScore = playerNames[i].parentElement.lastElementChild.textContent;
                fantasy.push(fantasyScore);
                let hotLevel = (parseFloat(average) * (parseFloat(percentage) / 100)) * 1.2;
                let coldLevel = ((parseFloat(average) * (parseFloat(percentage) / 100)) * 0.6);

                // Check if the player already has an icon
                let existingIcon = playerNames[i].parentElement.querySelector("i");
                if (existingIcon) {
                    // console.log("Player " + playerNames[i].textContent + " already has an icon.");
                    continue; // Skip to the next iteration
                }

                if (parseFloat(fantasyScore) >= parseFloat(hotLevel) && average !== 0 && fantasyScore !== 0 && percentage > 20) {
                    // console.log("Adding fire to " + playerNames[i].textContent);
                    addIcon(playerNames[i].parentElement, '<i class="customIcon" id="fire" style="content: url(\'/icons/fire.png\')"></i>');
                } else if (parseFloat(fantasyScore) <= parseFloat(coldLevel) && average !== 0 && fantasyScore !== 0 && percentage > 20 && average > 55) {
                    // console.log((playerNames[i].parentElement.id))
                    addIcon(playerNames[i].parentElement, '<i class="customIcon" id="ice" style="content: url(\'/icons/ice.png\')"></i>');
                }
            }
        }

        document.getElementById('usernameButton').addEventListener('click', function () {
            // Retrieve the value of the messageInput element
            const usernameInputValue = document.getElementById('usernameInput').value;

            // Call the changeUserName function and pass the messageInput value
            changeUserName(usernameInputValue);
        });

        document.getElementById('usernameInput').addEventListener('keydown', function (event) {
            if (event.key === 'Enter') {
                event.preventDefault(); // Prevent the default action to stop the form from being submitted
                const usernameInputValue = document.getElementById('usernameInput').value;
                changeUserName(usernameInputValue);
                document.getElementById('usernameInput').value = ''; // Clear the input field
            }
        });




        let userId = localStorage.getItem('userId');

        if (!userId) {
            fetch('/new-user-id')
                .then(response => response.json())
                .then(data => {
                    userId = data.userId;
                    localStorage.setItem('userId', userId);
                });
        }


        function changeUserName(newName) {
            // Send a request to the server to check if the new name is already taken

            if (newName.length > 15) {
                alert('Username is too long. Please keep it under 15 characters. Your username is ' + newName.length + ' characters long.');
                return;
            }
            fetch(`/check-username/${newName}`)
                .then(response => response.json())
                .then(data => {
                    if (data.isTaken) {
                        alert('This username is already taken');
                        // console.log('This username is already taken.');
                    } else {
                        // If the new name is not taken, update the user's name
                        fetch('/update-username', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                userId: userId,
                                newUsername: newName,
                            }),
                        })
                            .then(response => response.json())
                            .then(data => {
                                if (data.success) {

                                    let updateMessage = `${userId} has changed their username to ${newName}`;
                                    socket.send(updateMessage);

                                    fetch('/update-chat', {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/json',
                                        },
                                        body: JSON.stringify({
                                            link: trimmedLink,
                                            message: updateMessage,
                                        }),
                                    })
                                        .then(response => response.json())
                                        .catch((error) => {
                                            console.error('Error:', error);
                                        });

                                    userId = newName;
                                    localStorage.setItem('userId', newName);

                                    // Update the displayed username
                                    //document.getElementById('displayedUsername').textContent = newName;
                                } else {
                                    alert('Failed to update username. Username may be taken or contain profanity');
                                }
                            });
                    }
                });
        }




        const letterSubstitutions = {
            '3': ['e'],
            '4': ['a'],
            '@': ['a'],
            '5': ['s'],
            '1': ['l'],
            '1': ['i'],
            '7': ['t'],
            '8': ['b'],
            '9': ['g'],
            '0': ['o'],
            '2': ['z']
        };


        // function applySubstitutions(word) {
        //     let substitutedWord = '';
        //     for (const letter of word.toLowerCase()) {
        //         if (letterSubstitutions.hasOwnProperty(letter)) {
        //             const substitutions = letterSubstitutions[letter];
        //             substitutedWord += substitutions[Math.floor(Math.random() * substitutions.length)]; // Choose a random substitution
        //         } else {
        //             substitutedWord += letter;
        //         }
        //     }
        //     return substitutedWord;
        // }

        // function isProfanitySubstitute(word) {
        //     const substitutedWord = applySubstitutions(word);
        //     for (const profanity of profanityList) {
        //         if (substitutedWord.toLowerCase().includes(profanity)) {
        //             return true;
        //         }
        //     }
        //     return false;
        // }


        // function filterProfanity(message) {
        //     let words = message.split(' ');
        //     for (let i = 0; i < words.length; i++) {
        //         if (isProfanitySubstitute(words[i].toLowerCase())) {

        //             words[i] = '*'.repeat(words[i].length); // Censor the entire word
        //         }
        //     }
        //     return words.join(' ');
        // }





        // Store the timestamps of the last 5 messages for each user
        const userMessageTimestamps = {};

        function sendMessage() {
            const messageInput = document.getElementById('messageInput');
            const message = messageInput.value.trim();
            if (!message) {
                return;
            }
            if (message.length > 100) {
                alert('Message is too long. Please keep it under 100 characters. Your message is ' + message.length + ' characters long.');
                return;
            }

            // Check if the user has sent 5 messages in the last 10 seconds
            const now = Date.now();
            const timestamps = userMessageTimestamps[userId] || [];
            while (timestamps.length > 0 && now - timestamps[0] > 10000) {
                timestamps.shift();
            }
            if (timestamps.length >= 5) {
                alert('You have sent too many messages. Please wait a moment before sending another.');
                return;
            }

            // Record the timestamp of the new message
            timestamps.push(now);
            userMessageTimestamps[userId] = timestamps;

            let messageWithId = `${userId}: ${message}`;

            fetch('/update-chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    link: trimmedLink,
                    message: messageWithId,
                }),
            })
                .then(response => response.json())
                .catch((error) => {
                    console.error('Error:', error);
                });

            fetchAndUpdateChat();

            // Clear the input field after sending the message
            messageInput.value = '';
        }



        // Add an event listener for the 'Enter' key
        document.getElementById('messageInput').addEventListener('keydown', function (event) {
            if (event.key === 'Enter') {
                event.preventDefault(); // Prevent the default action to stop the form from being submitted
                sendMessage();
            }
        });




        socket.addEventListener('message', (event) => {
            if (event.data === 'playerDataChanged') {
                return;
            }
            const chatFeed = document.getElementById('chatFeed');
            const newMessage = document.createElement('p');
            if (event.data instanceof Blob) {
                const reader = new FileReader();
                reader.onload = function () {
                    newMessage.textContent = filterProfanity(this.result);
                    chatFeed.appendChild(newMessage);
                    chatFeed.scrollTop = chatFeed.scrollHeight; // Scroll to bottom
                }
                reader.readAsText(event.data);
            } else {
                newMessage.textContent = filterProfanity(event.data);
                chatFeed.appendChild(newMessage);
                chatFeed.scrollTop = chatFeed.scrollHeight; // Scroll to bottom
            }
        });

        const footyLiveBtn = document.getElementById('FootyLiveChat');
        const dtLiveBtn = document.getElementById('DTLiveChat');
        const chatFeed = document.getElementById('chatFeed');
        let dtLiveChatActive = false;
        let fetchChatInterval = null;

        function startDTLiveChatUpdates() {
            if (fetchChatInterval !== null) {
                clearInterval(fetchChatInterval);
            }
            fetchChatInterval = setInterval(toggleDTLiveChat, 10000);
        }

        function stopDTLiveChatUpdates() {
            if (fetchChatInterval !== null) {
                clearInterval(fetchChatInterval);
                fetchChatInterval = null;
            }
        }

        footyLiveBtn.addEventListener('click', function () {
            dtLiveChatActive = false;
            stopDTLiveChatUpdates();
            fetchAndUpdateChat();
            footyLiveBtn.style.backgroundColor = 'var(--lightrow-background-color)';
            dtLiveBtn.style.backgroundColor = 'var(--background-color)';
        });

        dtLiveBtn.addEventListener('click', function () {
            dtLiveChatActive = true;
            startDTLiveChatUpdates();
            toggleDTLiveChat();
            footyLiveBtn.style.backgroundColor = 'var(--background-color)';
            dtLiveBtn.style.backgroundColor = 'var(--lightrow-background-color)';
        });


        function toggleDTLiveChat() {
            fetch(`/dtlive-chat/${trimmedLink}`)
                .then(response => response.json())
                .then(data => {
                    chatFeed.innerHTML = ''; // Clear existing chat
                    data.reverse().forEach(chat => {
                        const messageElement = document.createElement('div');
                        messageElement.innerHTML = `<b>${chat.UserName}:</b> ${chat.ChatText}`;
                        chatFeed.appendChild(messageElement);
                    });
                })
                .catch(error => console.error('Error fetching DTLive chats:', error));
        }


        function fetchAndUpdateChat() {
            // Fetch icons from the server
            fetch('/get-all-chats')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to fetch chats');
                    }
                    return response.json();
                })
                .then(chatData => {
                    const chatFeed = document.getElementById('chatFeed');
                    chatFeed.innerHTML = ''; // Clear the chat feed

                    // Check if trimmedLink is in chatData
                    if (trimmedLink in chatData) {
                        const messagesForTrimmedLink = chatData[trimmedLink];
                        messagesForTrimmedLink.forEach(message => {
                            const newMessage = document.createElement('p');
                            let splitMessage = message.split(" ");
                            let userName = splitMessage.shift();
                            newMessage.innerHTML = `<b>${userName}</b> ${splitMessage.join(" ")}`;
                            chatFeed.appendChild(newMessage);
                        });
                    }
                })
                .catch(error => {
                    console.error('Error fetching chats:', error);
                });
        }
        fetchAndUpdateChat();

        document.getElementById('darkModeToggle').addEventListener('click', function () {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            if (currentTheme === 'dark') {
                document.documentElement.setAttribute('data-theme', 'light');
                localStorage.setItem('theme', 'light');

            } else {
                document.documentElement.setAttribute('data-theme', 'dark');
                localStorage.setItem('theme', 'dark');
            }
        });




        // document.getElementById('darkModeToggle').addEventListener('click', function () {
        //     const currentTheme = document.documentElement.getAttribute('data-theme');
        //     let newTheme = 'light';
        //     if (currentTheme === 'dark') {
        //         newTheme = 'light';
        //     } else {
        //         newTheme = 'dark';
        //     }
        //     document.documentElement.setAttribute('data-theme', newTheme);

        // });



        // DEBUG ONLY: Simulate updates to player stats
        // function simulateUpdates() {
        //     // Simulate updates to player stats
        //     window.playerData.team0.forEach(player => {
        //         const playerId = `${player.name}-${player.number}`;
        //         if (!previousDataTeam0[playerId]) {
        //             previousDataTeam0[playerId] = { ...player }; // Create a copy of the player data
        //         } else {
        //             // Update previous data with current values before applying changes
        //             Object.assign(previousDataTeam0[playerId], player);
        //         }
        //         console.log("Updating Team 0");
        //         // Update each stat with a random value between 0 and 5
        //         player.goals = getRandomInt(0, 5);
        //         player.behinds = getRandomInt(0, 5);
        //         player.kicks = getRandomInt(0, 5);
        //         player.handballs = getRandomInt(0, 5);
        //         player.marks = getRandomInt(0, 5);
        //         player.tackles = getRandomInt(0, 5);
        //         player.hitouts = getRandomInt(0, 5);
        //         player.fantasy = getRandomInt(0, 100);
        //     });

        //     window.playerData.team1.forEach(player => {
        //         const playerId = `${player.name}-${player.number}`;
        //         if (!previousDataTeam1[playerId]) {
        //             previousDataTeam1[playerId] = { ...player }; // Create a copy of the player data
        //         } else {
        //             // Update previous data with current values before applying changes
        //             Object.assign(previousDataTeam1[playerId], player);
        //         }
        //         console.log("Updating Team 1");
        //         // Update each stat with a random value between 0 and 5
        //         player.goals = getRandomInt(0, 5);
        //         player.behinds = getRandomInt(0, 5);
        //         player.kicks = getRandomInt(0, 5);
        //         player.handballs = getRandomInt(0, 5);
        //         player.marks = getRandomInt(0, 5);
        //         player.tackles = getRandomInt(0, 5);
        //         player.hitouts = getRandomInt(0, 5);
        //         player.fantasy = getRandomInt(0, 100);
        //     });

        //     // Re-render player data with simulated updates
        //     formatPlayerData(0, previousDataTeam0);
        //     formatPlayerData(1, previousDataTeam1);
        // }

        // // Function to get a random integer between min and max (inclusive)
        // function getRandomInt(min, max) {
        //     return Math.floor(Math.random() * (max - min + 1)) + min;
        // }

        // Simulate updates every 5 seconds
        //setInterval(simulateUpdates, 1000);

    </script>
    <script src="https://kit.fontawesome.com/0bb575a0ce.js" crossorigin="anonymous"></script>
</body>

</html>